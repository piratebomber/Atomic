// Atomic Standard Library - Threading and Concurrency
package Std.Threading api;

import Std.Platform;
import Std.Memory;
import Std.Collections;

// Thread handle and management
class Thread {
    var handle: i64;
    var thread_id: u32;
    var is_running: Bool;
    var is_detached: Bool;
    var exit_code: Optional(i32);
    
    fn Create(entry_point: fn() -> i32) -> Result(Self, String) {
        var thread: Self = {
            .handle = 0,
            .thread_id = 0,
            .is_running = False,
            .is_detached = False,
            .exit_code = Optional(i32).None()
        };
        
        var result: Result(Bool, String) = thread.CreateNativeThread(entry_point);
        if (not result.IsOk()) {
            return Result(Self, String).Error(result.Error());
        }
        
        return Result(Self, String).Ok(thread);
    }
    
    fn CreateWithData(entry_point: fn(*Void) -> i32, data: *Void) -> Result(Self, String) {
        var thread: Self = {
            .handle = 0,
            .thread_id = 0,
            .is_running = False,
            .is_detached = False,
            .exit_code = Optional(i32).None()
        };
        
        var result: Result(Bool, String) = thread.CreateNativeThreadWithData(entry_point, data);
        if (not result.IsOk()) {
            return Result(Self, String).Error(result.Error());
        }
        
        return Result(Self, String).Ok(thread);
    }
    
    fn Join(self: Self) -> Result(i32, String) {
        if (self.is_detached) {
            return Result(i32, String).Error("Cannot join detached thread");
        }
        
        if (not self.is_running) {
            if (self.exit_code.HasValue()) {
                return Result(i32, String).Ok(self.exit_code.Value());
            }
            return Result(i32, String).Error("Thread not started");
        }
        
        return self.JoinNative();
    }
    
    fn Detach(self: Self) -> Result(Bool, String) {
        if (self.is_detached) {
            return Result(Bool, String).Ok(True);
        }
        
        var result: Result(Bool, String) = self.DetachNative();
        if (result.IsOk()) {
            self.is_detached = True;
        }
        
        return result;
    }
    
    fn GetId(self: Self) -> u32 {
        return self.thread_id;
    }
    
    fn IsRunning(self: Self) -> Bool {
        return self.is_running;
    }
    
    // Platform-specific implementations
    fn CreateNativeThread(self: Self, entry_point: fn() -> i32) -> Result(Bool, String) {
        match (Platform.GetCurrentOS()) {
            case (Platform.OS.Windows) {
                return self.CreateWindowsThread(entry_point);
            }
            default {
                return self.CreatePthreadThread(entry_point);
            }
        }
    }
    
    fn CreateNativeThreadWithData(self: Self, entry_point: fn(*Void) -> i32, data: *Void) -> Result(Bool, String) {
        match (Platform.GetCurrentOS()) {
            case (Platform.OS.Windows) {
                return self.CreateWindowsThreadWithData(entry_point, data);
            }
            default {
                return self.CreatePthreadThreadWithData(entry_point, data);
            }
        }
    }
    
    fn CreateWindowsThread(self: Self, entry_point: fn() -> i32) -> Result(Bool, String) {
        var thread_data: *ThreadData = Memory.Allocate(SizeOf(ThreadData));
        thread_data.entry_point = entry_point;
        thread_data.user_data = null;
        
        self.handle = CreateThread(
            null, // Security attributes
            0,    // Stack size (default)
            WindowsThreadProc, // Thread procedure
            thread_data, // Parameter
            0,    // Creation flags
            &self.thread_id // Thread ID
        );\n        \n        if (self.handle == 0) {\n            Memory.Deallocate(thread_data);\n            return Result(Bool, String).Error(\"Failed to create Windows thread\");\n        }\n        \n        self.is_running = True;\n        return Result(Bool, String).Ok(True);\n    }\n    \n    fn CreateWindowsThreadWithData(self: Self, entry_point: fn(*Void) -> i32, data: *Void) -> Result(Bool, String) {\n        var thread_data: *ThreadDataWithParam = Memory.Allocate(SizeOf(ThreadDataWithParam));\n        thread_data.entry_point_with_data = entry_point;\n        thread_data.user_data = data;\n        \n        self.handle = CreateThread(\n            null,\n            0,\n            WindowsThreadProcWithData,\n            thread_data,\n            0,\n            &self.thread_id\n        );\n        \n        if (self.handle == 0) {\n            Memory.Deallocate(thread_data);\n            return Result(Bool, String).Error(\"Failed to create Windows thread with data\");\n        }\n        \n        self.is_running = True;\n        return Result(Bool, String).Ok(True);\n    }\n    \n    fn CreatePthreadThread(self: Self, entry_point: fn() -> i32) -> Result(Bool, String) {\n        var thread_data: *ThreadData = Memory.Allocate(SizeOf(ThreadData));\n        thread_data.entry_point = entry_point;\n        thread_data.user_data = null;\n        \n        var pthread_handle: pthread_t;\n        var result: i32 = pthread_create(&pthread_handle, null, PthreadProc, thread_data);\n        \n        if (result != 0) {\n            Memory.Deallocate(thread_data);\n            return Result(Bool, String).Error(\"Failed to create pthread\");\n        }\n        \n        self.handle = pthread_handle as i64;\n        self.thread_id = pthread_handle as u32; // Simplified\n        self.is_running = True;\n        return Result(Bool, String).Ok(True);\n    }\n    \n    fn CreatePthreadThreadWithData(self: Self, entry_point: fn(*Void) -> i32, data: *Void) -> Result(Bool, String) {\n        var thread_data: *ThreadDataWithParam = Memory.Allocate(SizeOf(ThreadDataWithParam));\n        thread_data.entry_point_with_data = entry_point;\n        thread_data.user_data = data;\n        \n        var pthread_handle: pthread_t;\n        var result: i32 = pthread_create(&pthread_handle, null, PthreadProcWithData, thread_data);\n        \n        if (result != 0) {\n            Memory.Deallocate(thread_data);\n            return Result(Bool, String).Error(\"Failed to create pthread with data\");\n        }\n        \n        self.handle = pthread_handle as i64;\n        self.thread_id = pthread_handle as u32;\n        self.is_running = True;\n        return Result(Bool, String).Ok(True);\n    }\n    \n    fn JoinNative(self: Self) -> Result(i32, String) {\n        match (Platform.GetCurrentOS()) {\n            case (Platform.OS.Windows) {\n                var wait_result: u32 = WaitForSingleObject(self.handle, 0xFFFFFFFF); // INFINITE\n                if (wait_result == 0) { // WAIT_OBJECT_0\n                    var exit_code: u32 = 0;\n                    GetExitCodeThread(self.handle, &exit_code);\n                    CloseHandle(self.handle);\n                    self.is_running = False;\n                    return Result(i32, String).Ok(exit_code as i32);\n                } else {\n                    return Result(i32, String).Error(\"Thread join failed\");\n                }\n            }\n            default {\n                var exit_code: *Void = null;\n                var result: i32 = pthread_join(self.handle as pthread_t, &exit_code);\n                if (result == 0) {\n                    self.is_running = False;\n                    return Result(i32, String).Ok(exit_code as i32);\n                } else {\n                    return Result(i32, String).Error(\"pthread_join failed\");\n                }\n            }\n        }\n    }\n    \n    fn DetachNative(self: Self) -> Result(Bool, String) {\n        match (Platform.GetCurrentOS()) {\n            case (Platform.OS.Windows) {\n                CloseHandle(self.handle);\n                return Result(Bool, String).Ok(True);\n            }\n            default {\n                var result: i32 = pthread_detach(self.handle as pthread_t);\n                return result == 0 ? Result(Bool, String).Ok(True) : Result(Bool, String).Error(\"pthread_detach failed\");\n            }\n        }\n    }\n}\n\n// Mutex for synchronization\nclass Mutex {\n    var handle: i64;\n    var is_initialized: Bool;\n    \n    fn Create() -> Result(Self, String) {\n        var mutex: Self = {\n            .handle = 0,\n            .is_initialized = False\n        };\n        \n        var result: Result(Bool, String) = mutex.InitializeNative();\n        if (not result.IsOk()) {\n            return Result(Self, String).Error(result.Error());\n        }\n        \n        return Result(Self, String).Ok(mutex);\n    }\n    \n    fn Lock(self: Self) -> Result(Bool, String) {\n        if (not self.is_initialized) {\n            return Result(Bool, String).Error(\"Mutex not initialized\");\n        }\n        \n        return self.LockNative();\n    }\n    \n    fn TryLock(self: Self) -> Result(Bool, String) {\n        if (not self.is_initialized) {\n            return Result(Bool, String).Error(\"Mutex not initialized\");\n        }\n        \n        return self.TryLockNative();\n    }\n    \n    fn Unlock(self: Self) -> Result(Bool, String) {\n        if (not self.is_initialized) {\n            return Result(Bool, String).Error(\"Mutex not initialized\");\n        }\n        \n        return self.UnlockNative();\n    }\n    \n    fn Destroy(self: Self) -> Result(Bool, String) {\n        if (not self.is_initialized) {\n            return Result(Bool, String).Ok(True);\n        }\n        \n        var result: Result(Bool, String) = self.DestroyNative();\n        if (result.IsOk()) {\n            self.is_initialized = False;\n        }\n        \n        return result;\n    }\n    \n    // Platform-specific implementations\n    fn InitializeNative(self: Self) -> Result(Bool, String) {\n        match (Platform.GetCurrentOS()) {\n            case (Platform.OS.Windows) {\n                var cs: *CRITICAL_SECTION = Memory.Allocate(SizeOf(CRITICAL_SECTION));\n                InitializeCriticalSection(cs);\n                self.handle = cs as i64;\n                self.is_initialized = True;\n                return Result(Bool, String).Ok(True);\n            }\n            default {\n                var mutex: *pthread_mutex_t = Memory.Allocate(SizeOf(pthread_mutex_t));\n                var result: i32 = pthread_mutex_init(mutex, null);\n                if (result == 0) {\n                    self.handle = mutex as i64;\n                    self.is_initialized = True;\n                    return Result(Bool, String).Ok(True);\n                } else {\n                    Memory.Deallocate(mutex);\n                    return Result(Bool, String).Error(\"pthread_mutex_init failed\");\n                }\n            }\n        }\n    }\n    \n    fn LockNative(self: Self) -> Result(Bool, String) {\n        match (Platform.GetCurrentOS()) {\n            case (Platform.OS.Windows) {\n                EnterCriticalSection(self.handle as *CRITICAL_SECTION);\n                return Result(Bool, String).Ok(True);\n            }\n            default {\n                var result: i32 = pthread_mutex_lock(self.handle as *pthread_mutex_t);\n                return result == 0 ? Result(Bool, String).Ok(True) : Result(Bool, String).Error(\"pthread_mutex_lock failed\");\n            }\n        }\n    }\n    \n    fn TryLockNative(self: Self) -> Result(Bool, String) {\n        match (Platform.GetCurrentOS()) {\n            case (Platform.OS.Windows) {\n                var result: Bool = TryEnterCriticalSection(self.handle as *CRITICAL_SECTION);\n                return Result(Bool, String).Ok(result);\n            }\n            default {\n                var result: i32 = pthread_mutex_trylock(self.handle as *pthread_mutex_t);\n                if (result == 0) {\n                    return Result(Bool, String).Ok(True);\n                } else if (result == 16) { // EBUSY\n                    return Result(Bool, String).Ok(False);\n                } else {\n                    return Result(Bool, String).Error(\"pthread_mutex_trylock failed\");\n                }\n            }\n        }\n    }\n    \n    fn UnlockNative(self: Self) -> Result(Bool, String) {\n        match (Platform.GetCurrentOS()) {\n            case (Platform.OS.Windows) {\n                LeaveCriticalSection(self.handle as *CRITICAL_SECTION);\n                return Result(Bool, String).Ok(True);\n            }\n            default {\n                var result: i32 = pthread_mutex_unlock(self.handle as *pthread_mutex_t);\n                return result == 0 ? Result(Bool, String).Ok(True) : Result(Bool, String).Error(\"pthread_mutex_unlock failed\");\n            }\n        }\n    }\n    \n    fn DestroyNative(self: Self) -> Result(Bool, String) {\n        match (Platform.GetCurrentOS()) {\n            case (Platform.OS.Windows) {\n                DeleteCriticalSection(self.handle as *CRITICAL_SECTION);\n                Memory.Deallocate(self.handle as *CRITICAL_SECTION);\n                return Result(Bool, String).Ok(True);\n            }\n            default {\n                var result: i32 = pthread_mutex_destroy(self.handle as *pthread_mutex_t);\n                Memory.Deallocate(self.handle as *pthread_mutex_t);\n                return result == 0 ? Result(Bool, String).Ok(True) : Result(Bool, String).Error(\"pthread_mutex_destroy failed\");\n            }\n        }\n    }\n}\n\n// Condition Variable\nclass ConditionVariable {\n    var handle: i64;\n    var is_initialized: Bool;\n    \n    fn Create() -> Result(Self, String) {\n        var cv: Self = {\n            .handle = 0,\n            .is_initialized = False\n        };\n        \n        var result: Result(Bool, String) = cv.InitializeNative();\n        if (not result.IsOk()) {\n            return Result(Self, String).Error(result.Error());\n        }\n        \n        return Result(Self, String).Ok(cv);\n    }\n    \n    fn Wait(self: Self, mutex: Mutex) -> Result(Bool, String) {\n        return self.WaitNative(mutex);\n    }\n    \n    fn WaitTimeout(self: Self, mutex: Mutex, timeout_ms: u32) -> Result(Bool, String) {\n        return self.WaitTimeoutNative(mutex, timeout_ms);\n    }\n    \n    fn NotifyOne(self: Self) -> Result(Bool, String) {\n        return self.NotifyOneNative();\n    }\n    \n    fn NotifyAll(self: Self) -> Result(Bool, String) {\n        return self.NotifyAllNative();\n    }\n    \n    fn Destroy(self: Self) -> Result(Bool, String) {\n        if (not self.is_initialized) {\n            return Result(Bool, String).Ok(True);\n        }\n        \n        var result: Result(Bool, String) = self.DestroyNative();\n        if (result.IsOk()) {\n            self.is_initialized = False;\n        }\n        \n        return result;\n    }\n    \n    // Platform-specific implementations\n    fn InitializeNative(self: Self) -> Result(Bool, String) {\n        match (Platform.GetCurrentOS()) {\n            case (Platform.OS.Windows) {\n                var cv: *CONDITION_VARIABLE = Memory.Allocate(SizeOf(CONDITION_VARIABLE));\n                InitializeConditionVariable(cv);\n                self.handle = cv as i64;\n                self.is_initialized = True;\n                return Result(Bool, String).Ok(True);\n            }\n            default {\n                var cv: *pthread_cond_t = Memory.Allocate(SizeOf(pthread_cond_t));\n                var result: i32 = pthread_cond_init(cv, null);\n                if (result == 0) {\n                    self.handle = cv as i64;\n                    self.is_initialized = True;\n                    return Result(Bool, String).Ok(True);\n                } else {\n                    Memory.Deallocate(cv);\n                    return Result(Bool, String).Error(\"pthread_cond_init failed\");\n                }\n            }\n        }\n    }\n    \n    fn WaitNative(self: Self, mutex: Mutex) -> Result(Bool, String) {\n        match (Platform.GetCurrentOS()) {\n            case (Platform.OS.Windows) {\n                var result: Bool = SleepConditionVariableCS(\n                    self.handle as *CONDITION_VARIABLE,\n                    mutex.handle as *CRITICAL_SECTION,\n                    0xFFFFFFFF // INFINITE\n                );\n                return Result(Bool, String).Ok(result);\n            }\n            default {\n                var result: i32 = pthread_cond_wait(\n                    self.handle as *pthread_cond_t,\n                    mutex.handle as *pthread_mutex_t\n                );\n                return result == 0 ? Result(Bool, String).Ok(True) : Result(Bool, String).Error(\"pthread_cond_wait failed\");\n            }\n        }\n    }\n    \n    fn WaitTimeoutNative(self: Self, mutex: Mutex, timeout_ms: u32) -> Result(Bool, String) {\n        match (Platform.GetCurrentOS()) {\n            case (Platform.OS.Windows) {\n                var result: Bool = SleepConditionVariableCS(\n                    self.handle as *CONDITION_VARIABLE,\n                    mutex.handle as *CRITICAL_SECTION,\n                    timeout_ms\n                );\n                return Result(Bool, String).Ok(result);\n            }\n            default {\n                // Convert timeout to timespec\n                var ts: timespec;\n                clock_gettime(0, &ts); // CLOCK_REALTIME\n                ts.tv_sec += timeout_ms / 1000;\n                ts.tv_nsec += (timeout_ms % 1000) * 1000000;\n                \n                var result: i32 = pthread_cond_timedwait(\n                    self.handle as *pthread_cond_t,\n                    mutex.handle as *pthread_mutex_t,\n                    &ts\n                );\n                \n                if (result == 0) {\n                    return Result(Bool, String).Ok(True);\n                } else if (result == 110) { // ETIMEDOUT\n                    return Result(Bool, String).Ok(False);\n                } else {\n                    return Result(Bool, String).Error(\"pthread_cond_timedwait failed\");\n                }\n            }\n        }\n    }\n    \n    fn NotifyOneNative(self: Self) -> Result(Bool, String) {\n        match (Platform.GetCurrentOS()) {\n            case (Platform.OS.Windows) {\n                WakeConditionVariable(self.handle as *CONDITION_VARIABLE);\n                return Result(Bool, String).Ok(True);\n            }\n            default {\n                var result: i32 = pthread_cond_signal(self.handle as *pthread_cond_t);\n                return result == 0 ? Result(Bool, String).Ok(True) : Result(Bool, String).Error(\"pthread_cond_signal failed\");\n            }\n        }\n    }\n    \n    fn NotifyAllNative(self: Self) -> Result(Bool, String) {\n        match (Platform.GetCurrentOS()) {\n            case (Platform.OS.Windows) {\n                WakeAllConditionVariable(self.handle as *CONDITION_VARIABLE);\n                return Result(Bool, String).Ok(True);\n            }\n            default {\n                var result: i32 = pthread_cond_broadcast(self.handle as *pthread_cond_t);\n                return result == 0 ? Result(Bool, String).Ok(True) : Result(Bool, String).Error(\"pthread_cond_broadcast failed\");\n            }\n        }\n    }\n    \n    fn DestroyNative(self: Self) -> Result(Bool, String) {\n        match (Platform.GetCurrentOS()) {\n            case (Platform.OS.Windows) {\n                // Windows condition variables don't need explicit cleanup\n                Memory.Deallocate(self.handle as *CONDITION_VARIABLE);\n                return Result(Bool, String).Ok(True);\n            }\n            default {\n                var result: i32 = pthread_cond_destroy(self.handle as *pthread_cond_t);\n                Memory.Deallocate(self.handle as *pthread_cond_t);\n                return result == 0 ? Result(Bool, String).Ok(True) : Result(Bool, String).Error(\"pthread_cond_destroy failed\");\n            }\n        }\n    }\n}\n\n// Thread-safe queue\nclass ThreadSafeQueue(T: Type) {\n    var queue: Queue(T);\n    var mutex: Mutex;\n    var condition: ConditionVariable;\n    \n    fn Create() -> Result(Self, String) {\n        var mutex_result: Result(Mutex, String) = Mutex.Create();\n        if (not mutex_result.IsOk()) {\n            return Result(Self, String).Error(mutex_result.Error());\n        }\n        \n        var cv_result: Result(ConditionVariable, String) = ConditionVariable.Create();\n        if (not cv_result.IsOk()) {\n            return Result(Self, String).Error(cv_result.Error());\n        }\n        \n        var ts_queue: Self = {\n            .queue = Queue(T).Create(),\n            .mutex = mutex_result.Value(),\n            .condition = cv_result.Value()\n        };\n        \n        return Result(Self, String).Ok(ts_queue);\n    }\n    \n    fn Push(self: Self, item: T) -> Result(Bool, String) {\n        var lock_result: Result(Bool, String) = self.mutex.Lock();\n        if (not lock_result.IsOk()) {\n            return lock_result;\n        }\n        \n        self.queue.Enqueue(item);\n        self.condition.NotifyOne();\n        self.mutex.Unlock();\n        \n        return Result(Bool, String).Ok(True);\n    }\n    \n    fn Pop(self: Self) -> Result(T, String) {\n        var lock_result: Result(Bool, String) = self.mutex.Lock();\n        if (not lock_result.IsOk()) {\n            return Result(T, String).Error(lock_result.Error());\n        }\n        \n        while (self.queue.IsEmpty()) {\n            var wait_result: Result(Bool, String) = self.condition.Wait(self.mutex);\n            if (not wait_result.IsOk()) {\n                self.mutex.Unlock();\n                return Result(T, String).Error(wait_result.Error());\n            }\n        }\n        \n        var item_opt: Optional(T) = self.queue.Dequeue();\n        self.mutex.Unlock();\n        \n        if (item_opt.HasValue()) {\n            return Result(T, String).Ok(item_opt.Value());\n        } else {\n            return Result(T, String).Error(\"Queue is empty\");\n        }\n    }\n    \n    fn TryPop(self: Self) -> Optional(T) {\n        var lock_result: Result(Bool, String) = self.mutex.TryLock();\n        if (not lock_result.IsOk() or not lock_result.Value()) {\n            return Optional(T).None();\n        }\n        \n        var item_opt: Optional(T) = self.queue.Dequeue();\n        self.mutex.Unlock();\n        \n        return item_opt;\n    }\n    \n    fn Size(self: Self) -> u64 {\n        self.mutex.Lock();\n        var size: u64 = self.queue.Size();\n        self.mutex.Unlock();\n        return size;\n    }\n    \n    fn IsEmpty(self: Self) -> Bool {\n        self.mutex.Lock();\n        var empty: Bool = self.queue.IsEmpty();\n        self.mutex.Unlock();\n        return empty;\n    }\n}\n\n// Thread pool for task execution\nclass ThreadPool {\n    var threads: Array(Thread);\n    var task_queue: ThreadSafeQueue(Task);\n    var is_running: Bool;\n    var thread_count: i32;\n    \n    fn Create(thread_count: i32) -> Result(Self, String) {\n        var queue_result: Result(ThreadSafeQueue(Task), String) = ThreadSafeQueue(Task).Create();\n        if (not queue_result.IsOk()) {\n            return Result(Self, String).Error(queue_result.Error());\n        }\n        \n        var pool: Self = {\n            .threads = Array(Thread)(),\n            .task_queue = queue_result.Value(),\n            .is_running = True,\n            .thread_count = thread_count\n        };\n        \n        // Create worker threads\n        var i: i32 = 0;\n        while (i < thread_count) {\n            var thread_result: Result(Thread, String) = Thread.CreateWithData(WorkerThreadProc, &pool);\n            if (not thread_result.IsOk()) {\n                return Result(Self, String).Error(thread_result.Error());\n            }\n            \n            pool.threads.Push(thread_result.Value());\n            i += 1;\n        }\n        \n        return Result(Self, String).Ok(pool);\n    }\n    \n    fn Submit(self: Self, task: Task) -> Result(Bool, String) {\n        if (not self.is_running) {\n            return Result(Bool, String).Error(\"Thread pool is not running\");\n        }\n        \n        return self.task_queue.Push(task);\n    }\n    \n    fn Shutdown(self: Self) {\n        self.is_running = False;\n        \n        // Add poison pills to wake up all threads\n        var i: i32 = 0;\n        while (i < self.thread_count) {\n            var poison_task: Task = {\n                .function = null,\n                .data = null,\n                .is_poison = True\n            };\n            self.task_queue.Push(poison_task);\n            i += 1;\n        }\n        \n        // Wait for all threads to finish\n        i = 0;\n        while (i < self.threads.Size()) {\n            self.threads[i].Join();\n            i += 1;\n        }\n    }\n}\n\n// Task structure for thread pool\nstruct Task {\n    var function: fn(*Void) -> i32;\n    var data: *Void;\n    var is_poison: Bool;\n}\n\n// Worker thread procedure for thread pool\nfn WorkerThreadProc(pool_ptr: *Void) -> i32 {\n    var pool: *ThreadPool = pool_ptr;\n    \n    while (pool.is_running) {\n        var task_result: Result(Task, String) = pool.task_queue.Pop();\n        if (task_result.IsOk()) {\n            var task: Task = task_result.Value();\n            \n            if (task.is_poison) {\n                break; // Shutdown signal\n            }\n            \n            if (task.function != null) {\n                task.function(task.data);\n            }\n        }\n    }\n    \n    return 0;\n}\n\n// Utility functions\nfn GetCurrentThreadId() -> u32 {\n    match (Platform.GetCurrentOS()) {\n        case (Platform.OS.Windows) {\n            return GetCurrentThreadId_Win32();\n        }\n        default {\n            return pthread_self() as u32;\n        }\n    }\n}\n\nfn Sleep(milliseconds: u32) {\n    match (Platform.GetCurrentOS()) {\n        case (Platform.OS.Windows) {\n            Sleep_Win32(milliseconds);\n        }\n        default {\n            usleep(milliseconds * 1000); // Convert to microseconds\n        }\n    }\n}\n\nfn Yield() {\n    match (Platform.GetCurrentOS()) {\n        case (Platform.OS.Windows) {\n            SwitchToThread();\n        }\n        default {\n            sched_yield();\n        }\n    }\n}\n\n// Thread data structures\nstruct ThreadData {\n    var entry_point: fn() -> i32;\n    var user_data: *Void;\n}\n\nstruct ThreadDataWithParam {\n    var entry_point_with_data: fn(*Void) -> i32;\n    var user_data: *Void;\n}\n\n// Thread procedure wrappers\nfn WindowsThreadProc(param: *Void) -> u32 {\n    var data: *ThreadData = param;\n    var result: i32 = data.entry_point();\n    Memory.Deallocate(data);\n    return result as u32;\n}\n\nfn WindowsThreadProcWithData(param: *Void) -> u32 {\n    var data: *ThreadDataWithParam = param;\n    var result: i32 = data.entry_point_with_data(data.user_data);\n    Memory.Deallocate(data);\n    return result as u32;\n}\n\nfn PthreadProc(param: *Void) -> *Void {\n    var data: *ThreadData = param;\n    var result: i32 = data.entry_point();\n    Memory.Deallocate(data);\n    return result as *Void;\n}\n\nfn PthreadProcWithData(param: *Void) -> *Void {\n    var data: *ThreadDataWithParam = param;\n    var result: i32 = data.entry_point_with_data(data.user_data);\n    Memory.Deallocate(data);\n    return result as *Void;\n}\n\n// Platform-specific system calls and structures\n// Windows\nfn CreateThread(security: *Void, stack_size: u64, start_address: fn(*Void) -> u32, parameter: *Void, flags: u32, thread_id: *u32) -> i64;\nfn WaitForSingleObject(handle: i64, milliseconds: u32) -> u32;\nfn GetExitCodeThread(thread: i64, exit_code: *u32) -> Bool;\nfn CloseHandle(handle: i64) -> Bool;\nfn InitializeCriticalSection(cs: *CRITICAL_SECTION);\nfn EnterCriticalSection(cs: *CRITICAL_SECTION);\nfn TryEnterCriticalSection(cs: *CRITICAL_SECTION) -> Bool;\nfn LeaveCriticalSection(cs: *CRITICAL_SECTION);\nfn DeleteCriticalSection(cs: *CRITICAL_SECTION);\nfn InitializeConditionVariable(cv: *CONDITION_VARIABLE);\nfn SleepConditionVariableCS(cv: *CONDITION_VARIABLE, cs: *CRITICAL_SECTION, milliseconds: u32) -> Bool;\nfn WakeConditionVariable(cv: *CONDITION_VARIABLE);\nfn WakeAllConditionVariable(cv: *CONDITION_VARIABLE);\nfn GetCurrentThreadId_Win32() -> u32;\nfn Sleep_Win32(milliseconds: u32);\nfn SwitchToThread() -> Bool;\n\n// Unix/POSIX\nfn pthread_create(thread: *pthread_t, attr: *pthread_attr_t, start_routine: fn(*Void) -> *Void, arg: *Void) -> i32;\nfn pthread_join(thread: pthread_t, retval: **Void) -> i32;\nfn pthread_detach(thread: pthread_t) -> i32;\nfn pthread_self() -> pthread_t;\nfn pthread_mutex_init(mutex: *pthread_mutex_t, attr: *pthread_mutexattr_t) -> i32;\nfn pthread_mutex_lock(mutex: *pthread_mutex_t) -> i32;\nfn pthread_mutex_trylock(mutex: *pthread_mutex_t) -> i32;\nfn pthread_mutex_unlock(mutex: *pthread_mutex_t) -> i32;\nfn pthread_mutex_destroy(mutex: *pthread_mutex_t) -> i32;\nfn pthread_cond_init(cond: *pthread_cond_t, attr: *pthread_condattr_t) -> i32;\nfn pthread_cond_wait(cond: *pthread_cond_t, mutex: *pthread_mutex_t) -> i32;\nfn pthread_cond_timedwait(cond: *pthread_cond_t, mutex: *pthread_mutex_t, abstime: *timespec) -> i32;\nfn pthread_cond_signal(cond: *pthread_cond_t) -> i32;\nfn pthread_cond_broadcast(cond: *pthread_cond_t) -> i32;\nfn pthread_cond_destroy(cond: *pthread_cond_t) -> i32;\nfn usleep(microseconds: u32) -> i32;\nfn sched_yield() -> i32;\nfn clock_gettime(clock_id: i32, tp: *timespec) -> i32;\n\n// Platform-specific types\nstruct CRITICAL_SECTION {\n    // Windows critical section - opaque structure\n    var data: Array(u8); // Platform-specific size\n}\n\nstruct CONDITION_VARIABLE {\n    // Windows condition variable - opaque structure\n    var data: *Void;\n}\n\nstruct timespec {\n    var tv_sec: i64;\n    var tv_nsec: i64;\n}\n\n// Opaque pthread types\nstruct pthread_t; // Platform-specific\nstruct pthread_attr_t; // Platform-specific\nstruct pthread_mutex_t; // Platform-specific\nstruct pthread_mutexattr_t; // Platform-specific\nstruct pthread_cond_t; // Platform-specific\nstruct pthread_condattr_t; // Platform-specific